----- DIFF | diff file1 file2---------------------------------------------------------------
< = removed  
> = added 

5c5,6 = on line 5, c= Changed 
11a13,15 = a = added 13-15 new lines

----- SHOW MORE details | diff -u file1 file2---------------------------------------------------------------

----- SHOW MORE details and create a file showing this | diff -u file1OG.py file2fixed.py > file3.diff---------------------------------------------------------------

----- PATCH - takes a file generated by diff and applies changes to original file  ---------------------------------------------------------------
        patch ogfile < difffile

----- GIT SETUP / LOGIN  ---------------------------------------------------------------
git config --global user.email "me@example.com"
git config --global user.name "My name"

----- CREATE NEW REPO  ---------------------------------------------------------------
mkdir <dirName>
cd <dirName>
git init

----- TRACK USING GIT (STAGING)  ---------------------------------------------------------------
git add file.py
git status

----- GET CURRENT WORKING TREE & PENDING CHANGES   ---------------------------------------------------------------
git status

----- COMMIT w/ EDITOR  ---------------------------------------------------------------
git commit (opens text editor)

(commit message will be needed, add notes about the commit)

----- COMMIT WITH COMMENT W/O opening editor |  ---------------------------------------------------------------
git commit -m '<MESSAGE>'

-----   ---------------------------------------------------------------
#Study guide: Git
#There are three sections: 
1. Git directory, 
2. Working tree, 
3. Staging area.

#Git config command
#The Git config command is used to set the values to identify who made changes to Git repositories. 
#To set the values of user.email and user.name to your email and name, 
#: ~$ git config  - -global user.email "#me@example.com"
#: ~$ git config  - -global user.name “My name”
#(Also to check our config: git config -l)


#Git init command = can create a new empty repository in a current directory or re-initialize an existing one. 
#: ~/checks$ git init

#Git ls -la command = checks that an identified directory exists.
#: ~/checks$ ls -la

#The ls-l.git checks inside the directory to see the different things that it contains. 
#This is called the Git directory. The Git directory is a database for your Git project 
#that stores the changes and the change history.
#: ~/checks$ ls -l .git/

#Git add command allows Git to track your file and uses the selected file as a parameter 
#when adding it to the staging area. The staging area is a file maintained by Git that 
#contains all the information about what files and changes are going to go into your next commit.
#:~/checks$ git add disk_usage.py

#Git status command = to get some information about the current working tree and pending changes.
#:~/checks$ git status

#Git commit command = to remove changes made from the staging area to the .git directory. When 
#this command is run, it tells Git to save changes. A text editor is opened that allows a commit message to be entered.
#:~/checks$ git commit

#git log = check commit history, author of each commit, timestamp and commit message

#Guidelines for writing commit messages
#A commit message is generally broken into two sections: a short summary and a description of the changes. 
#When the git commit command is run, Git will open a text editor to write your commit message. A good commit 
#message includes the following:

#Summary: The first line contains the summary, formatted as a header, containing 50 characters or less. 

#Description: The description is usually kept under 72 characters and provides detailed information about 
#the change. It can include references to bugs or issues that will be fixed with the change. It also can 
#include links to more information when relevant. 

#Example of a commit message:  #https://commit.style/
 
-----   ---------------------------------------------------------------

Shortcut to commit:  a shortcut to stage any changes to tracked files and commit in one step
git commit -a
git commit -a -m "this is a message"

### HEAD is a bookmark or a pointer to the current branch
### HEAD is a bookmark or a pointer to the current branch
### HEAD is a bookmark or a pointer to the current branch
### HEAD is a bookmark or a pointer to the current branch
### HEAD is a bookmark or a pointer to the current branch

#shows changes files in repo, useful to track down a change that broke your code
git log -p 


#takes commit id as parameter and displays about the commit and associated cache
git show <commit id>

#Shows stats about change and how many lines were added or removed
--stat 

#show changes that are staged but not committed
git diff --staged

#review change before committing them
git add -p

#git remove
git Rm

#git move
git mv

#to ignore files, you have to create a .gitignore file.
#write the filename to the .gitignore file.
echo ignoreThisfile.txt > .gitignore
#then commit


# automatically stages the files that have been locally modified. New files which have not been published yet are not affected.
git commit -a
 
# produces patch text. A patch file is used to share your local changes with others without pushing your changes to the main branch of the repo.
git log -p


#  shows you one or more object(s) such as blobs, trees, tags, and commits.
git show

#is similar to the Linux `diff` command, and can show the changes between commits, changes between the working tree and index, 
# changes between two trees, changes from a merge, and so on.
git diff

# is an alias of $ git diff --cached, which  shows all staged files compared to the named commit.
git diff --staged

# allows a user to interactively review patches before adding to the current commit.
git add -p

# is similar to the Linux `mv` command. This command can move or rename a file, directory, or symlink.
git mv

# is similar to the Linux `rm` command. This command deletes or removes a file from the working tree. 
git rm

# used to switch branches. For example, you might want to pull from your main branch. 
# In this case, you would use the command git checkout main. This will switch to your main branch, 
# allowing you to pull. Then you could switch to another branch by using the command  git checkout <branch>.
git checkout

# used to switch branches. For example, you might want to pull from your main branch. In this case, 
# you would use the command git checkout main. This will switch to your main branch, allowing you to pull. 
# Then you could switch to another branch by using the command  git checkout <branch>.
git reset

# Which will temporarily shelve or stash your current changes. This way, your current changes are kept safe, 
# and you can come back to them if needed.
git stash

# is used to make changes to your most recent commit after-the-fact, which can be useful for making notes 
# about or adding files to your most recent commit. Be aware that this git --amend command rewrites and 
# replaces your previous commit, so it is best not to use this command on a published commit.
git commit --amend


# makes a new commit which effectively rolls back a previous commit. Unlike the git reset command which 
# rewrites your commit history, the git revert command creates a new commit which undoes the changes in 
# a specific commit. Therefore, a revert command is generally safer than a reset command.
git revert
 

#Additionally, there are some interesting considerations about how git object data is stored, such as the usage of SHA-1.
# 1. Confirming that the contents of a file have not changed (digital signature). 
# 2. Serving as an identifier for the file itself (a token or fingerprint).
Sha-1


# can be used to list, create, or delete branches.
git branch

# can be used to create a new branch in your repository. 
git branch <name>

# can be used to delete a branch from your repository.
git branch -d <name>

# forces a branch to be deleted.
git branch -D <name>
 
# switches your current working branch.
git checkout <branch>
 
# creates a new branch and makes it your current working branch. 
git checkout -b <new-branch>

# joins changes from one branch into another branch.
git merge <branch>

# can only be used after merge conflicts. This command will abort the merge and try to go back to the pre-merge state.
git merge --abort

# prints an ASCII graph of the commit and merge history.
git log --graph 

# prints each commit on a single line.
git log --oneline

 
 ---------------------------------------- REMOTES -----------------------------------------------
# allows you to manage the set of repositories or “remotes” whose branches you track
$ git remote 

# is similar to $ git remote, but adding the -v shows more information such as the remote URL.
git remote -v

# shows some information about a single remote repo.
git remote show <name>

# fetches updates for remotes or remote groups.
git remote update

# can download objects and refs from a single repo, a single URL, or from several repositories at once.
git fetch

# lists remote branches and can be combined with other branch arguments to manage remote branches.
git branch -r


--------------------------------------- NOTES ---------------------------------------
# CI/CD: The name for the entire continuous integration and continuous deployment system

# Code reviews: The deliberate and methodical gathering of other programmers to examine each other's code for errors to increase the code quality and reduces the amount of bugs

# Continuous deployment (CD): New code is deployed often after it has been automatically built and tested

# Continuous integration (CI): A system that will automatically build and test our code every time there's a change

# Fix up: The decision to discard commit messages for that commit 

# Forking: A way of creating a copy of the given repository so that it belongs to our user

# Indirect merges: GitHub can merge a pull request automatically if the head branch is directly or indirectly merged into the base branch externally

# Issue tracker (bug tracker): A tracker that shows tasks that need to be done, the state they're in and who's working on them

# Merge commits: All commits from the feature branch are added to the base branch

# Pipelines: The specific steps that need to run to obtain the desired result

# Pull request: A procedure where new code is examined before it is merged to create a branch or master branch 

# Squash commits: The decision add commit messages together and an editor opens to make any necessary changes